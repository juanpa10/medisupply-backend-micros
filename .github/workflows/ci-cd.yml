name: Micros CI/CD → ECR + ECS (auto)

on:
  push:
    branches: ["main"]
  workflow_dispatch: {}

# Variables de organización (ponlas en repo Settings → Actions → Variables)
#  - AWS_REGION: us-east-1
#  - ECR_REPOSITORY: medisupply
#  - CLUSTER: medisupply
#  - ALB_NAME: portal-web-alb
#  - ECS_SG_ID: sg-xxxxxxxx   (Security Group de tareas ECS)
env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
  CLUSTER: ${{ vars.CLUSTER }}
  ALB_NAME: ${{ vars.ALB_NAME }}
  ECS_SG_ID: ${{ vars.ECS_SG_ID }}

jobs:
  discover:
    name: Discover microservices
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4

      - name: Build matrix from services/*
        id: mk
        run: |
          set -e
          if [ ! -d services ]; then
            echo 'matrix={"include":[]}' >> "$GITHUB_OUTPUT"
            exit 0
          fi

          arr="[]"
          # Cada micro debe tener services/<name>/{Dockerfile,service.json}
          for dir in $(find services -maxdepth 1 -mindepth 1 -type d 2>/dev/null | sort); do
            if [ -f "$dir/Dockerfile" ] && [ -f "$dir/service.json" ]; then
              name=$(jq -r '.name' "$dir/service.json")
              arr=$(jq --arg n "$name" --arg c "$dir" '. + [{"name":$n,"context":$c}]' <<<"$arr")
            fi
          done

          echo "Servicios detectados:"
          echo "$arr" | jq .
          echo "matrix={\"include\":$(jq -c <<<"$arr")}" >> "$GITHUB_OUTPUT"

  build_push:
    name: Build & Push to ECR
    needs: discover
    if: ${{ needs.discover.outputs.matrix != '' && needs.discover.outputs.matrix != '{"include":[]}' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.discover.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Docker metadata (${{ matrix.name }})
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}
          tags: |
            type=sha,prefix=${{ matrix.name }}-
            type=ref,event=branch,prefix=${{ matrix.name }}-
            type=raw,value=${{ matrix.name }}-latest,enable={{is_default_branch}}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push ${{ matrix.name }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          push: true
          platforms: linux/amd64
          provenance: false
          sbom: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to ECS/ALB
    needs: [discover, build_push]
    if: ${{ needs.discover.outputs.matrix != '' && needs.discover.outputs.matrix != '{"include":[]}' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy each micro (task def + service + ALB rule)
        env:
          ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          set -e

          alb_arn=$(aws elbv2 describe-load-balancers --names "${ALB_NAME}" --query 'LoadBalancers[0].LoadBalancerArn' --output text --region "${AWS_REGION}")
          listener_arn=$(aws elbv2 describe-listeners --load-balancer-arn "$alb_arn" --query 'Listeners[?Port==`80`].ListenerArn' --output text --region "${AWS_REGION}")
          vpc_id=$(aws elbv2 describe-load-balancers --load-balancer-arns "$alb_arn" --query 'LoadBalancers[0].VpcId' --output text --region "${AWS_REGION}")
          subnets=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=${vpc_id}" --query 'Subnets[?MapPublicIpOnLaunch==`true`].SubnetId' --output text --region "${AWS_REGION}")
          subnets_csv=$(echo "$subnets" | sed 's/ /,/g')

          for dir in $(find services -maxdepth 1 -mindepth 1 -type d 2>/dev/null | sort); do
            [ -f "$dir/Dockerfile" ] && [ -f "$dir/service.json" ] || continue

            name=$(jq -r '.name' "$dir/service.json")
            containerPort=$(jq -r '.containerPort' "$dir/service.json")
            pathPrefix=$(jq -r '.pathPrefix' "$dir.service.json" 2>/dev/null || jq -r '.pathPrefix' "$dir/service.json")
            healthPath=$(jq -r '.healthPath' "$dir/service.json")
            cpu=$(jq -r '.cpu' "$dir/service.json")
            memory=$(jq -r '.memory' "$dir/service.json")
            desired=$(jq -r '.desiredCount' "$dir/service.json")

            image="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${name}-latest"
            log_group="/ecs/${name}"
            tg_name="${name}-tg"
            svc_name="${name}-svc"

            echo "==> Deploy ${name} | port=${containerPort} | path=${pathPrefix}"

            # Log group (idempotente)
            aws logs create-log-group --log-group-name "$log_group" --region "${AWS_REGION}" 2>/dev/null || true

            # Target group (crear si no existe)
            tg_arn=$(aws elbv2 describe-target-groups --names "$tg_name" --query 'TargetGroups[0].TargetGroupArn' --output text --region "${AWS_REGION}" 2>/dev/null || true)
            if [ "$tg_arn" = "None" ] || [ -z "$tg_arn" ]; then
              tg_arn=$(aws elbv2 create-target-group \
                --name "$tg_name" \
                --protocol HTTP \
                --port ${containerPort} \
                --vpc-id "$vpc_id" \
                --target-type ip \
                --health-check-path "${healthPath}" \
                --health-check-port traffic-port \
                --matcher HttpCode=200-399 \
                --query 'TargetGroups[0].TargetGroupArn' \
                --output text --region "${AWS_REGION}")
            fi

            # Regla de ALB (solo si pathPrefix no está vacío)
            if [ -n "$pathPrefix" ] && [ "$pathPrefix" != "null" ]; then
              # ¿Existe ya una regla con ese path?
              existing_rule=$(aws elbv2 describe-rules --listener-arn "$listener_arn" \
                --query "Rules[?contains(join('', Conditions[?Field=='path-pattern'].Values[]),'${pathPrefix%*}')] | [0].RuleArn" \
                --output text --region "${AWS_REGION}" 2>/dev/null || true)

              if [ "$existing_rule" = "None" ] || [ -z "$existing_rule" ]; then
                # Busca prioridad libre a partir de 200
                prio=200
                while aws elbv2 describe-rules --listener-arn "$listener_arn" --query "Rules[?Priority=='${prio}']" --output text --region "${AWS_REGION}" | grep -q .; do
                  prio=$((prio+1))
                done
                aws elbv2 create-rule \
                  --listener-arn "$listener_arn" \
                  --priority $prio \
                  --conditions Field=path-pattern,Values="${pathPrefix}" \
                  --actions Type=forward,TargetGroupArn="$tg_arn" \
                  --region "${AWS_REGION}" >/dev/null
              fi
            fi

            # Task Definition con jq (evita problemas de here-doc/YAML)
            td_file=$(mktemp)
            jq -n \
              --arg family "$name" \
              --arg cpu "$cpu" \
              --arg memory "$memory" \
              --arg execRole "arn:aws:iam::${ACCOUNT_ID}:role/ecsTaskExecutionRole" \
              --arg cname "$name" \
              --arg image "$image" \
              --arg log_group "$log_group" \
              --arg region "$AWS_REGION" \
              --arg stream "$name" \
              --argjson cport ${containerPort} \
            '{
              family: $family,
              networkMode: "awsvpc",
              requiresCompatibilities: ["FARGATE"],
              cpu: $cpu,
              memory: $memory,
              executionRoleArn: $execRole,
              containerDefinitions: [{
                name: $cname,
                image: $image,
                portMappings: [{ containerPort: $cport, protocol: "tcp" }],
                essential: true,
                logConfiguration: {
                  logDriver: "awslogs",
                  options: {
                    "awslogs-group": $log_group,
                    "awslogs-region": $region,
                    "awslogs-stream-prefix": $stream
                  }
                }
              }]
            }' > "$td_file"

            rev=$(aws ecs register-task-definition \
              --cli-input-json file://"$td_file" \
              --query 'taskDefinition.revision' --output text --region "${AWS_REGION}")
            rm -f "$td_file"

            # Crear service si no existe; si existe, actualizar & redeploy
            svc_status=$(aws ecs describe-services --cluster "${CLUSTER}" --services "${svc_name}" --query 'services[0].status' --output text --region "${AWS_REGION}" 2>/dev/null || true)
            if [ "$svc_status" = "None" ] || [ -z "$svc_status" ]; then
              aws ecs create-service \
                --cluster "${CLUSTER}" \
                --service-name "${svc_name}" \
                --task-definition "${name}:${rev}" \
                --desired-count ${desired} \
                --launch-type FARGATE \
                --network-configuration "awsvpcConfiguration={subnets=[$subnets_csv],securityGroups=[${ECS_SG_ID}],assignPublicIp=ENABLED}" \
                --load-balancers "targetGroupArn=${tg_arn},containerName=${name},containerPort=${containerPort}" \
                --region "${AWS_REGION}" >/dev/null
            else
              aws ecs update-service \
                --cluster "${CLUSTER}" \
                --service "${svc_name}" \
                --task-definition "${name}:${rev}" \
                --desired-count ${desired} \
                --force-new-deployment \
                --region "${AWS_REGION}" >/dev/null
            fi

            echo "✔ ${name} deployed"
          done
